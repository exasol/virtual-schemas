package com.exasol.adapter.dialects;

import static org.junit.Assert.assertTrue;

import java.io.File;
import java.io.IOException;
import java.lang.reflect.InvocationTargetException;
import java.nio.file.Files;
import java.sql.Connection;
import java.util.*;
import java.util.stream.Stream;

import javax.json.JsonObject;

import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.MethodSource;

import com.exasol.adapter.AdapterException;
import com.exasol.adapter.AdapterProperties;
import com.exasol.adapter.request.AdapterRequest;
import com.exasol.adapter.request.PushDownRequest;
import com.exasol.adapter.request.parser.RequestParser;
import com.exasol.adapter.sql.SqlNodeVisitor;
import com.exasol.utils.JsonHelper;

/**
 * This is an integration test for Virtual Schemas. The idea is that the <code>jdbc-adapter</code> and the Exasol
 * database have a common set of test data to use. By doing this we avoid to write and keep tests in multiple locations.
 * <p>
 * This class executes the given (in JSON file) test scenarios and asserts the results.
 * <p>
 * Writing a new test means writing new test data files. The test files are in JSON format and have to have the
 * extension <code>.json</code>. The following attributes have to be present:
 * <dl>
 * <dt><code>testSchema</code></dt>
 * <dd>This is the schema definition. This test does not use the schema definition, since the test case parses the
 * push-down request directly.</dd>
 * <dt><code>testCases</code></dt>
 * <dd>A list of test cases to be performed on the schema.
 * <dd>
 * </dl>
 * <p>
 * The list of test cases contains:
 * </p>
 * <dl>
 * <dt><code>testQuery</code></dt>
 * <dd>A single string containing the test query. This test does not use the test query, since the test case parses the
 * push-down request directly.</dd>
 * <dt><code>expectedPushdownRequest</code></dt>
 * <dd>A list of pushdownRequests as they are generated by the database. This is a list because a single query can
 * generate multiple push-downs (e.g. <code>JOIN</code>).</dd>
 * <dt><code>expectedPushdownResponse</code></dt>
 * <dd>For each dialect that should be tested a list of strings with the returned push-down SQLs.</dd></dd>
 * </dl>
 */
class FileBasedIntegrationTest {
    private static final String INTEGRATION_TESTFILES_DIR = "target/test-classes/integration";
    private static final String TEST_FILE_KEY_TESTCASES = "testCases";
    private static final String TEST_FILE_KEY_EXP_PD_REQUEST = "expectedPushdownRequest";
    private static final String TEST_FILE_KEY_EXP_PD_RESPONSE = "expectedPushdownResponse";

    static Stream<File> listTestFiles() {
        final File testDir = new File(INTEGRATION_TESTFILES_DIR);
        return Arrays.stream(testDir.listFiles((dir, name) -> name.endsWith(".json")));
    }

    @MethodSource("listTestFiles")
    @ParameterizedTest
    void testPushDownFromTestFile(final File testFile)
            throws IOException, ClassNotFoundException, NoSuchMethodException, IllegalAccessException,
            InvocationTargetException, InstantiationException, AdapterException {
        final String jsonTest = new String(Files.readAllBytes(testFile.toPath()));
        final int numberOfTests = getNumberOfTestsFrom(jsonTest);
        for (int testNr = 0; testNr < numberOfTests; testNr++) {
            final List<PushDownRequest> PushDownRequests = getPushDownRequestsFrom(jsonTest, testNr);
            final Map<String, List<String>> expectedPushDownQueries = getExpectedPushDownQueriesFrom(jsonTest, testNr);
            for (final String dialect : expectedPushDownQueries.keySet()) {
                for (final PushDownRequest PushDownRequest : PushDownRequests) {
                    final String pushDownQuery = generatePushDownQuery(dialect, PushDownRequest, testFile.getName(),
                            testNr);
                    assertExpectedPushDowns(expectedPushDownQueries.get(dialect), pushDownQuery, testFile.getName(),
                            testNr, dialect);
                }
            }
        }
    }

    private void assertExpectedPushDowns(final List<String> expectedPushDownQueries, final String pushDownQuery,
            final String testFile, final int testNr, final String dialect) {
        final boolean foundInExpected = expectedPushDownQueries.stream().anyMatch(pushDownQuery::contains);
        final StringBuilder errorMessage = new StringBuilder();
        if (!foundInExpected) {
            errorMessage.append("Generated push-down: ");
            errorMessage.append(pushDownQuery);
            errorMessage.append(" not found in expected push-downs (");
            errorMessage.append(expectedPushDownQueries);
            errorMessage.append("). Testfile: ");
            errorMessage.append(testFile);
            errorMessage.append(" ,Test#: ");
            errorMessage.append(testNr);
            errorMessage.append(" ,Dialect: ");
            errorMessage.append(dialect);
        }
        assertTrue(errorMessage.toString(), foundInExpected);
    }

    private int getNumberOfTestsFrom(final String jsonTest) {
        final JsonObject root = JsonHelper.getJsonObject(jsonTest);
        return root.getJsonArray(TEST_FILE_KEY_TESTCASES).size();
    }

    private List<PushDownRequest> getPushDownRequestsFrom(final String jsonTest, final int testNr) {
        final JsonObject root = JsonHelper.getJsonObject(jsonTest);
        final JsonObject test = root.getJsonArray(TEST_FILE_KEY_TESTCASES).getValuesAs(JsonObject.class).get(testNr);
        final int numberOfPushDownRequests = test.getJsonArray(TEST_FILE_KEY_EXP_PD_REQUEST).size();
        final List<PushDownRequest> PushDownRequests = new ArrayList<>(numberOfPushDownRequests);
        for (int requestNr = 0; requestNr < numberOfPushDownRequests; requestNr++) {
            final String request = test.getJsonArray(TEST_FILE_KEY_EXP_PD_REQUEST).get(requestNr).toString();
            final RequestParser parser = new RequestParser();
            final AdapterRequest parsedRequest = parser.parse(request);
            PushDownRequests.add((PushDownRequest) parsedRequest);
        }
        return PushDownRequests;
    }

    private String generatePushDownQuery(final String dialect, final PushDownRequest PushDownRequest,
            final String testFile, final int testNr) throws AdapterException, ClassNotFoundException,
            NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException {
        final String schemaName = "LS";
        final SqlGenerationContext context = new SqlGenerationContext("", schemaName, false);
        final Class<?> dialectClass = getDialectClass(dialect);
        final SqlDialect sqlDialect = (SqlDialect) dialectClass
                .getConstructor(Connection.class, AdapterProperties.class)
                .newInstance(null, AdapterProperties.emptyProperties());
        final SqlNodeVisitor<String> sqlGeneratorVisitor = sqlDialect.getSqlGenerationVisitor(context);
        try {
            return PushDownRequest.getSelect().accept(sqlGeneratorVisitor);
        } catch (final Exception e) {
            System.err.println("Exception in: " + testFile + " Test#: " + testNr + " dialect: " + dialect);
            throw e;
        }
    }

    protected Class<?> getDialectClass(final String dialect) throws ClassNotFoundException {
        final String fullyQualifiedDialectName = "com.exasol.adapter.dialects." + dialect.toLowerCase() + "." + dialect
                + "SqlDialect";
        final Class<?> dialectClass = Class.forName(fullyQualifiedDialectName);
        return dialectClass;
    }

    private Map<String, List<String>> getExpectedPushDownQueriesFrom(final String jsonTest, final int testNr) {
        final JsonObject root = JsonHelper.getJsonObject(jsonTest);
        final JsonObject test = root.getJsonArray(TEST_FILE_KEY_TESTCASES).getValuesAs(JsonObject.class).get(testNr);
        final JsonObject expectedResponses = test.getJsonObject(TEST_FILE_KEY_EXP_PD_RESPONSE);
        final Map<String, List<String>> expectedQueriesForDialects = new HashMap<>();
        for (final String dialect : expectedResponses.keySet()) {
            final int numberOfPushDownResponses = test.getJsonObject(TEST_FILE_KEY_EXP_PD_RESPONSE)
                    .getJsonArray(dialect).size();
            final List<String> pushDownResponses = new ArrayList<>(numberOfPushDownResponses);
            for (int pushDownNr = 0; pushDownNr < numberOfPushDownResponses; pushDownNr++) {
                pushDownResponses
                        .add(test.getJsonObject(TEST_FILE_KEY_EXP_PD_RESPONSE).getJsonArray(dialect).get(pushDownNr)
                                .toString().replaceAll("\\\\\"", "\"").replaceAll("^\"+", "").replaceAll("\"$", ""));
            }
            expectedQueriesForDialects.put(dialect, pushDownResponses);
        }
        return expectedQueriesForDialects;
    }
}